<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: Innate::Node</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">Innate::Node</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/innate/node_rb.html">
                lib/innate/node.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
The nervous system of {<a href="../Innate.html">Innate</a>}, so you can
relax.
</p>
<p>
<a href="Node.html">Node</a> may be <a
href="Node.html#M000336">included</a> into any class to make it a valid
responder to requests.
</p>
<p>
The major difference between this and the old Ramaze controller is that
every <a href="Node.html">Node</a> acts as a standalone application with
its own dispatcher.
</p>
<p>
What&#8216;s also an important difference is the fact that {<a
href="Node.html">Node</a>} is a module, so we don&#8216;t have to spend a
lot of time designing the perfect subclassing scheme.
</p>
<p>
This makes dispatching more fun, avoids a lot of processing that is done by
{Rack} anyway and lets you tailor your application down to the last action
exactly the way you want without worrying about side-effects to other {<a
href="Node.html">Node</a>}s.
</p>
<p>
Upon inclusion, it will also include {<a
href="Trinity.html">Innate::Trinity</a>} and {<a
href="Helper.html">Innate::Helper</a>} to <a
href="Node.html#M000341">provide</a> you with {<a
href="Request.html">Innate::Request</a>}, {<a
href="Response.html">Innate::Response</a>}, {<a
href="Session.html">Innate::Session</a>} instances, and all the standard
helper methods as well as the ability to simply add other helpers.
</p>
<p>
Please note that method_missing will <em>not</em> be considered when
building an {<a href="Action.html">Action</a>}. There might be future
demand for this, but for now you can simply use `def index(*args); end` to
make a catch-all action.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000345">action_found</a>&nbsp;&nbsp;
      <a href="#M000346">action_missing</a>&nbsp;&nbsp;
      <a href="#M000355">alias_view</a>&nbsp;&nbsp;
      <a href="#M000367">binding</a>&nbsp;&nbsp;
      <a href="#M000343">call</a>&nbsp;&nbsp;
      <a href="#M000349">fill_action</a>&nbsp;&nbsp;
      <a href="#M000356">find_aliased_view</a>&nbsp;&nbsp;
      <a href="#M000350">find_layout</a>&nbsp;&nbsp;
      <a href="#M000351">find_method</a>&nbsp;&nbsp;
      <a href="#M000348">find_provide</a>&nbsp;&nbsp;
      <a href="#M000353">find_view</a>&nbsp;&nbsp;
      <a href="#M000338">generate_mapping</a>&nbsp;&nbsp;
      <a href="#M000336">included</a>&nbsp;&nbsp;
      <a href="#M000358">layout</a>&nbsp;&nbsp;
      <a href="#M000372">layout_mappings</a>&nbsp;&nbsp;
      <a href="#M000340">map</a>&nbsp;&nbsp;
      <a href="#M000371">map_layouts</a>&nbsp;&nbsp;
      <a href="#M000369">map_views</a>&nbsp;&nbsp;
      <a href="#M000339">mapping</a>&nbsp;&nbsp;
      <a href="#M000374">needs_method?</a>&nbsp;&nbsp;
      <a href="#M000373">options</a>&nbsp;&nbsp;
      <a href="#M000359">patterns_for</a>&nbsp;&nbsp;
      <a href="#M000366">possible_exts_for</a>&nbsp;&nbsp;
      <a href="#M000365">possible_paths_for</a>&nbsp;&nbsp;
      <a href="#M000341">provide</a>&nbsp;&nbsp;
      <a href="#M000375">provide_set?</a>&nbsp;&nbsp;
      <a href="#M000342">provides</a>&nbsp;&nbsp;
      <a href="#M000347">resolve</a>&nbsp;&nbsp;
      <a href="#M000368">root_mappings</a>&nbsp;&nbsp;
      <a href="#M000337">setup</a>&nbsp;&nbsp;
      <a href="#M000357">to_layout</a>&nbsp;&nbsp;
      <a href="#M000360">to_template</a>&nbsp;&nbsp;
      <a href="#M000354">to_view</a>&nbsp;&nbsp;
      <a href="#M000344">try_resolve</a>&nbsp;&nbsp;
      <a href="#M000363">update_layout_mappings</a>&nbsp;&nbsp;
      <a href="#M000364">update_mapping_shared</a>&nbsp;&nbsp;
      <a href="#M000352">update_method_arities</a>&nbsp;&nbsp;
      <a href="#M000361">update_template_mappings</a>&nbsp;&nbsp;
      <a href="#M000362">update_view_mappings</a>&nbsp;&nbsp;
      <a href="#M000370">view_mappings</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->
    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">
        <span class="include-name"><a href="Traited.html">Traited</a></span>
      </div>
    </div>

    <div id="section">


    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">NODE_LIST</td>
          <td>=</td>
          <td class="context-item-value">Set.new</td>
        </tr>
        </table>
      </div>
    </div>



    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">layout_templates</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">method_arities</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">view_templates</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M000338" class="method-detail">
        <a name="M000338"></a>

        <div class="method-heading">
          <a href="Node.src/M000338.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000338.html');return false;">
          <span class="method-name">generate_mapping</span><span class="method-args">(object_name = self.name)</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000336" class="method-detail">
        <a name="M000336"></a>

        <div class="method-heading">
          <a href="Node.src/M000336.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000336.html');return false;">
          <span class="method-name">included</span><span class="method-args">(into)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Upon inclusion we make ourselves comfortable.
</p>
        </div>
      </div>

      <div id="method-M000337" class="method-detail">
        <a name="M000337"></a>

        <div class="method-heading">
          <a href="Node.src/M000337.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000337.html');return false;">
          <span class="method-name">setup</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
node <a href="Node.html#M000339">mapping</a> procedure
</p>
<p>
when <a href="Node.html">Node</a> is <a
href="Node.html#M000336">included</a> into an object, it&#8216;s added to
NODE_LIST when object::<a href="Node.html#M000340">map</a>(location) is
sent, it maps the object into DynaMap when Innate.start is issued, it calls
Node::setup Node::setup iterates NODE_LIST and maps all objects not in
DynaMap by using Node::generate_mapping(object.name) as location
</p>
<p>
when object::<a href="Node.html#M000340">map</a>(nil) is sent, the object
will be skipped in Node::setup
</p>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000345" class="method-detail">
        <a name="M000345"></a>

        <div class="method-heading">
          <a href="Node.src/M000345.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000345.html');return false;">
          <span class="method-name">action_found</span><span class="method-args">(action)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Executed once an {<a href="Action.html">Action</a>} has been found.
</p>
<p>
Reset the {<a href="Response.html">Innate::Response</a>} instance, catch
:respond and :redirect. {<a href="Action.html#M000445">Action#call</a>} has
to return a String.
</p>
<p>
@param [<a href="Action.html">Action</a>] action
</p>
<p>
@return [<a href="Response.html">Innate::Response</a>]
</p>
<p>
@api external @see <a href="Action.html#M000445">Action#call</a> <a
href="Response.html">Innate::Response</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000346" class="method-detail">
        <a name="M000346"></a>

        <div class="method-heading">
          <a href="Node.src/M000346.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000346.html');return false;">
          <span class="method-name">action_missing</span><span class="method-args">(path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
The default handler in case no action was found, kind of method_missing.
Must modify the response in order to have any lasting effect.
</p>
<p>
Reasoning:
</p>
<ul>
<li>We are doing this is in order to avoid tons of special error handling code
that would impact runtime and make the overall API more complicated.

</li>
<li>This cannot be a normal action is that methods defined in {<a
href="Node.html">Innate::Node</a>} will never be considered for actions.

</li>
</ul>
<p>
To use a normal action with template do following:
</p>
<p>
@example
</p>
<pre>
  class Hi
    include Innate::Node
    map '/'

    def self.action_missing(path)
      return if path == '/not_found'
      # No normal action, runs on bare metal
      try_resolve('/not_found')
    end

    def not_found
      # Normal action
      &quot;Sorry, I do not exist&quot;
    end
  end
</pre>
<p>
@param [String] path
</p>
<p>
@api external @see <a href="Response.html">Innate::Response</a> <a
href="Node.html#M000344">Node#try_resolve</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000355" class="method-detail">
        <a name="M000355"></a>

        <div class="method-heading">
          <a href="Node.src/M000355.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000355.html');return false;">
          <span class="method-name">alias_view</span><span class="method-args">(to, from, node = nil)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Aliasing one view from another. The aliases are inherited, and the optional
third <tt>node</tt> parameter indicates the <a href="Node.html">Node</a> to
take the view from.
</p>
<p>
The argument order is identical with `alias` and `alias_method`, which
quite honestly confuses me, but at least we stay consistent.
</p>
<p>
@example
</p>
<pre>
  class Foo
    include Innate::Node

    # Use the 'foo' view when calling 'bar'
    alias_view 'bar', 'foo'

    # Use the 'foo' view from FooBar node when calling 'bar'
    alias_view 'bar', 'foo', FooBar
  end
</pre>
<p>
Note that the parameters have been simplified in comparision with
Ramaze::Controller::template where the second parameter may be a Controller
or the name of the template. We take that now as an optional third
parameter.
</p>
<p>
@param [to_s] to view that should be replaced @param [to_s] from view to
use or <a href="Node.html">Node</a>. @param [nil?, <a
href="Node.html">Node</a>] node optionally obtain view from this <a
href="Node.html">Node</a>
</p>
<p>
@api external @see Node::find_aliased_view @author manveru
</p>
        </div>
      </div>

      <div id="method-M000367" class="method-detail">
        <a name="M000367"></a>

        <div class="method-heading">
          <a href="Node.src/M000367.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000367.html');return false;">
          <span class="method-name">binding</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
For compatibility with new Kernel#binding behaviour in 1.9
</p>
<p>
@return [Binding] <a href="Node.html#M000367">binding</a> of the instance
being rendered. @see <a href="Action.html#M000446">Action#binding</a>
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000343" class="method-detail">
        <a name="M000343"></a>

        <div class="method-heading">
          <a href="Node.src/M000343.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000343.html');return false;">
          <span class="method-name">call</span><span class="method-args">(env)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
This makes the <a href="Node.html">Node</a> a valid application for Rack.
<tt>env</tt> is the environment hash passed from the Rack::Handler
</p>
<p>
We rely on correct PATH_INFO.
</p>
<p>
As defined by the Rack spec, PATH_INFO may be empty if it wants the root of
the application, so we insert &#8217;/&#8217; to make our dispatcher
simple.
</p>
<p>
<a href="../Innate.html">Innate</a> will not rescue any errors for you or
do any error handling, this should be done by an underlying middleware.
</p>
<p>
We do however log errors at some vital points in order to <a
href="Node.html#M000341">provide</a> you with feedback in your logs.
</p>
<p>
A lot of functionality in here relies on the fact that <a
href="Node.html#M000343">call</a> is executed within <a
href="Current.html#M000483">Current#call</a> which populates the variables
used by <a href="Trinity.html">Trinity</a>. So if you use the <a
href="Node.html">Node</a> directly as a middleware make sure that you use
<a href="Current.html">Innate::Current</a> as a middleware before it.
</p>
<p>
@param [Hash] env
</p>
<p>
@return [Array]
</p>
<p>
@api external @see <a href="Response.html#M000510">Response#reset</a> <a
href="Node.html#M000344">Node#try_resolve</a> <a
href="Session.html#M000492">Session#flush</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000349" class="method-detail">
        <a name="M000349"></a>

        <div class="method-heading">
          <a href="Node.src/M000349.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000349.html');return false;">
          <span class="method-name">fill_action</span><span class="method-args">(action, given_name)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Now we&#8216;re talking {<a href="Action.html">Action</a>}, we try to find
a matching template and method, if we can&#8216;t find either we go to the
next pattern, otherwise we answer with an {<a
href="Action.html">Action</a>} with everything we know so far about the
demands of the client.
</p>
<p>
@param [String] given_name the name extracted from REQUEST_PATH @param
[String] wish
</p>
<p>
@return [<a href="Action.html">Action</a>, nil]
</p>
<p>
@api internal @see <a href="Node.html#M000351">Node#find_method</a> <a
href="Node.html#M000353">Node#find_view</a> <a
href="Node.html#M000350">Node#find_layout</a> <a
href="Node.html#M000359">Node#patterns_for</a>
</p>
<pre>
     Action#wish Action#merge!
</pre>
<p>
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000356" class="method-detail">
        <a name="M000356"></a>

        <div class="method-heading">
          <a href="Node.src/M000356.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000356.html');return false;">
          <span class="method-name">find_aliased_view</span><span class="method-args">(action_name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Resolve one level of aliasing for the given <tt>action_name</tt> and
<tt>wish</tt>.
</p>
<p>
@param [String] action_name @param [String] wish
</p>
<p>
@return [nil, String] the absolute path to the aliased template or nil
</p>
<p>
@api internal @see Node::alias_view Node::find_view @author manveru
</p>
        </div>
      </div>

      <div id="method-M000350" class="method-detail">
        <a name="M000350"></a>

        <div class="method-heading">
          <a href="Node.src/M000350.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000350.html');return false;">
          <span class="method-name">find_layout</span><span class="method-args">(name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Try to find a suitable value for the <a
href="Node.html#M000358">layout</a>. This may be a template or the name of
a method.
</p>
<p>
If a <a href="Node.html#M000358">layout</a> could be found, an Array with
two elements is returned, the first indicating the kind of <a
href="Node.html#M000358">layout</a> (:<a
href="Node.html#M000358">layout</a>|:view|:method), the second the found
value, which may be a String or Symbol.
</p>
<p>
@param [String] name @param [String] wish
</p>
<p>
@return [Array, nil]
</p>
<p>
@api external @see <a href="Node.html#M000357">Node#to_layout</a> <a
href="Node.html#M000351">Node#find_method</a> <a
href="Node.html#M000353">Node#find_view</a> @author manveru
</p>
<p>
@todo allow layouts combined of method and view&#8230; hairy :)
</p>
        </div>
      </div>

      <div id="method-M000351" class="method-detail">
        <a name="M000351"></a>

        <div class="method-heading">
          <a href="Node.src/M000351.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000351.html');return false;">
          <span class="method-name">find_method</span><span class="method-args">(name, params)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
We check arity if possible, but will happily dispatch to any method that
has default parameters. If you don&#8216;t want your method to be
responsible for messing up a request you should think twice about the
arguments you specify due to limitations in Ruby.
</p>
<p>
So if you want your method to take only one parameter which may have a
default value following will work fine:
</p>
<pre>
  def index(foo = &quot;bar&quot;, *rest)
</pre>
<p>
But following will respond to /arg1/arg2 and then fail due to
ArgumentError:
</p>
<pre>
  def index(foo = &quot;bar&quot;)
</pre>
<p>
Here a glance at how parameters are expressed in arity:
</p>
<pre>
  def index(a)                  # =&gt; 1
  def index(a = :a)             # =&gt; -1
  def index(a, *r)              # =&gt; -2
  def index(a = :a, *r)         # =&gt; -1

  def index(a, b)               # =&gt; 2
  def index(a, b, *r)           # =&gt; -3
  def index(a, b = :b)          # =&gt; -2
  def index(a, b = :b, *r)      # =&gt; -2

  def index(a = :a, b = :b)     # =&gt; -1
  def index(a = :a, b = :b, *r) # =&gt; -1
</pre>
<p>
@param [String, Symbol] name @param [Array] params
</p>
<p>
@return [String, Symbol]
</p>
<p>
@api external @see <a href="Node.html#M000349">Node#fill_action</a> <a
href="Node.html#M000350">Node#find_layout</a> @author manveru
</p>
<p>
@todo Once 1.9 is mainstream we can use Method#parameters to do accurate
</p>
<pre>
      prediction
</pre>
        </div>
      </div>

      <div id="method-M000348" class="method-detail">
        <a name="M000348"></a>

        <div class="method-heading">
          <a href="Node.src/M000348.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000348.html');return false;">
          <span class="method-name">find_provide</span><span class="method-args">(path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Resolve possible <a href="Node.html#M000342">provides</a> for the given
<tt>path</tt> from {<a href="Node.html#M000342">provides</a>}.
</p>
<p>
@param [String] path
</p>
<p>
@return [Array] with name, wish, engine
</p>
<p>
@api internal @see Node::provide Node::provides @author manveru
</p>
        </div>
      </div>

      <div id="method-M000353" class="method-detail">
        <a name="M000353"></a>

        <div class="method-heading">
          <a href="Node.src/M000353.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000353.html');return false;">
          <span class="method-name">find_view</span><span class="method-args">(action_name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Try to find the best template for the given basename and wish and respect
aliased views.
</p>
<p>
@param [to_s] action_name @param [to_s] wish
</p>
<p>
@return [String, nil] depending whether a template could be found
</p>
<p>
@api external @see <a href="Node.html#M000360">Node#to_template</a> <a
href="Node.html#M000356">Node#find_aliased_view</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000358" class="method-detail">
        <a name="M000358"></a>

        <div class="method-heading">
          <a href="Node.src/M000358.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000358.html');return false;">
          <span class="method-name">layout</span><span class="method-args">(name = nil, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Define a <a href="Node.html#M000358">layout</a> to use on this <a
href="Node.html">Node</a>.
</p>
<p>
A <a href="Node.html">Node</a> can only have one <a
href="Node.html#M000358">layout</a>, although the template being chosen can
depend on {<a href="Node.html#M000342">provides</a>}.
</p>
<p>
@param [String, to_s] name basename without extension of the <a
href="Node.html#M000358">layout</a> to use @param [Proc, <a
href="Node.html#M000343">call</a>] block called on every dispatch if no
name given
</p>
<p>
@return [Proc, String] The assigned name or block
</p>
<p>
@api external @see <a href="Node.html#M000350">Node#find_layout</a>
Node#layout_paths <a href="Node.html#M000357">Node#to_layout</a>
Node#app_layout @author manveru
</p>
<p>
NOTE:
</p>
<pre>
  The behaviour of Node#layout changed significantly from Ramaze, instead
  of multitudes of obscure options and methods like deny_layout we simply
  take a block and use the returned value as the name for the layout. No
  layout will be used if the block returns nil.
</pre>
        </div>
      </div>

      <div id="method-M000372" class="method-detail">
        <a name="M000372"></a>

        <div class="method-heading">
          <a href="Node.src/M000372.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000372.html');return false;">
          <span class="method-name">layout_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Combine Innate.options.layouts with either the `ancestral_trait[:layouts]`
or the {<a href="Node.html#M000339">Node#mapping</a>} if the trait yields
an empty Array.
</p>
<p>
@return [Array&lt;String&gt;, Array&lt;Array&lt;String&gt;&gt;]
</p>
<p>
@api external @see {<a href="Node.html#M000371">Node#map_layouts</a>}
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000340" class="method-detail">
        <a name="M000340"></a>

        <div class="method-heading">
          <a href="Node.src/M000340.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000340.html');return false;">
          <span class="method-name">map</span><span class="method-args">(location)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Shortcut to <a href="Node.html#M000340">map</a> or remap this <a
href="Node.html">Node</a>.
</p>
<p>
@example Usage for explicit <a href="Node.html#M000339">mapping</a>:
</p>
<pre>
  class FooBar
    include Innate::Node
    map '/foo_bar'
  end

  Innate.to(FooBar) # =&gt; '/foo_bar'
</pre>
<p>
@example Usage for automatic <a href="Node.html#M000339">mapping</a>:
</p>
<pre>
  class FooBar
    include Innate::Node
    map mapping
  end

  Innate.to(FooBar) # =&gt; '/foo_bar'
</pre>
<p>
@param [to_s] location
</p>
<p>
@api external @see Innate::SingletonMethods::map @author manveru
</p>
        </div>
      </div>

      <div id="method-M000371" class="method-detail">
        <a name="M000371"></a>

        <div class="method-heading">
          <a href="Node.src/M000371.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000371.html');return false;">
          <span class="method-name">map_layouts</span><span class="method-args">(*locations)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Set the paths for lookup below the Innate.options.layouts paths.
</p>
<p>
@param [String, Array&lt;String&gt;] locations
</p>
<pre>
  Any number of strings indicating the paths where layout templates may
  be located, relative to Innate.options.roots/Innate.options.layouts
</pre>
<p>
@return [<a href="Node.html">Node</a>] self
</p>
<p>
@api external @see {<a href="Node.html#M000372">Node#layout_mappings</a>}
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000369" class="method-detail">
        <a name="M000369"></a>

        <div class="method-heading">
          <a href="Node.src/M000369.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000369.html');return false;">
          <span class="method-name">map_views</span><span class="method-args">(*locations)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Set the paths for lookup below the Innate.options.views paths.
</p>
<p>
@param [String, Array&lt;String&gt;] locations
</p>
<pre>
  Any number of strings indicating the paths where view templates may be
  located, relative to Innate.options.roots/Innate.options.views
</pre>
<p>
@return [<a href="Node.html">Node</a>] self
</p>
<p>
@api external @see {<a href="Node.html#M000370">Node#view_mappings</a>}
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000339" class="method-detail">
        <a name="M000339"></a>

        <div class="method-heading">
          <a href="Node.src/M000339.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000339.html');return false;">
          <span class="method-name">mapping</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Tries to find the relative url that this {<a href="Node.html">Node</a>} is
mapped to. If it cannot find one it will instead generate one based on the
snake_cased name of itself.
</p>
<p>
@example Usage:
</p>
<pre>
  class FooBar
    include Innate::Node
  end
  FooBar.mapping # =&gt; '/foo_bar'
</pre>
<p>
@return [String] the relative path to the node
</p>
<p>
@api external @see <a
href="SingletonMethods.html#M000303">Innate::SingletonMethods#to</a>
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000374" class="method-detail">
        <a name="M000374"></a>

        <div class="method-heading">
          <a href="Node.src/M000374.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000374.html');return false;">
          <span class="method-name">needs_method?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Whether an {<a href="Action.html">Action</a>} can be built without a
method.
</p>
<p>
The default is to allow actions that use only a view template, but you
might want to turn this on, for example if you have partials in your view
directories.
</p>
<p>
@example turning <a href="Node.html#M000374">needs_method?</a> on
</p>
<pre>
  class Foo
    Innate.node('/')
  end

  Foo.needs_method? # =&gt; true
  Foo.trait :needs_method =&gt; false
  Foo.needs_method? # =&gt; false
</pre>
<p>
@return [true, false] (false)
</p>
<p>
@api external @see {<a href="Node.html#M000349">Node#fill_action</a>}
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000373" class="method-detail">
        <a name="M000373"></a>

        <div class="method-heading">
          <a href="Node.src/M000373.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000373.html');return false;">
          <span class="method-name">options</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000359" class="method-detail">
        <a name="M000359"></a>

        <div class="method-heading">
          <a href="Node.src/M000359.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000359.html');return false;">
          <span class="method-name">patterns_for</span><span class="method-args">(path) {|action_name, params| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
The innate beauty in Nitro, Ramaze, and {<a
href="../Innate.html">Innate</a>}.
</p>
<p>
Will yield the name of the action and parameter for the action method in
order of significance.
</p>
<pre>
  def foo__bar # responds to /foo/bar
  def foo(bar) # also responds to /foo/bar
</pre>
<p>
But foo__bar takes precedence because it&#8216;s more explicit.
</p>
<p>
The last fallback will always be the index action with all of the path
turned into parameters.
</p>
<p>
@example yielding possible combinations of action names and params
</p>
<pre>
  class Foo; include Innate::Node; map '/'; end

  Foo.patterns_for('/'){|action, params| p action =&gt; params }
  # =&gt; {&quot;index&quot;=&gt;[]}

  Foo.patterns_for('/foo/bar'){|action, params| p action =&gt; params }
  # =&gt; {&quot;foo__bar&quot;=&gt;[]}
  # =&gt; {&quot;foo&quot;=&gt;[&quot;bar&quot;]}
  # =&gt; {&quot;index&quot;=&gt;[&quot;foo&quot;, &quot;bar&quot;]}

  Foo.patterns_for('/foo/bar/baz'){|action, params| p action =&gt; params }
  # =&gt; {&quot;foo__bar__baz&quot;=&gt;[]}
  # =&gt; {&quot;foo__bar&quot;=&gt;[&quot;baz&quot;]}
  # =&gt; {&quot;foo&quot;=&gt;[&quot;bar&quot;, &quot;baz&quot;]}
  # =&gt; {&quot;index&quot;=&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]}
</pre>
<p>
@param [String, split] path usually the PATH_INFO
</p>
<p>
@return [<a href="Action.html">Action</a>] it actually returns the first
non-nil/false result of yield
</p>
<p>
@api internal @see <a href="Node.html#M000349">Node#fill_action</a> @author
manveru
</p>
        </div>
      </div>

      <div id="method-M000366" class="method-detail">
        <a name="M000366"></a>

        <div class="method-heading">
          <a href="Node.src/M000366.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000366.html');return false;">
          <span class="method-name">possible_exts_for</span><span class="method-args">(wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Answer with an array of possible extensions in order of significance for
the given <tt>wish</tt>.
</p>
<p>
@param [to_s] wish the extension (no leading &#8217;.&#8217;)
</p>
<p>
@return [Array] list of exts valid for this <tt>wish</tt>
</p>
<p>
@api internal @see <a href="Node.html#M000360">Node#to_template</a>
View::exts_of <a href="Node.html#M000342">Node#provides</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000365" class="method-detail">
        <a name="M000365"></a>

        <div class="method-heading">
          <a href="Node.src/M000365.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000365.html');return false;">
          <span class="method-name">possible_paths_for</span><span class="method-args">(mappings)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Answer with an array of possible paths in order of significance for
template lookup of the given <tt>mappings</tt>.
</p>
<p>
@param [<a href="Node.html#M000340">map</a>] An array two Arrays of inner
and outer directories.
</p>
<p>
@return [Array] @see <a href="Node.html#M000362">update_view_mappings</a>
<a href="Node.html#M000363">update_layout_mappings</a> <a
href="Node.html#M000361">update_template_mappings</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000341" class="method-detail">
        <a name="M000341"></a>

        <div class="method-heading">
          <a href="Node.src/M000341.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000341.html');return false;">
          <span class="method-name">provide</span><span class="method-args">(format, param = {}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Specify which way contents are provided and processed.
</p>
<p>
Use this to set a templating engine, custom Content-Type, or pass a block
to take over the processing of the {<a href="Action.html">Action</a>} and
template yourself.
</p>
<p>
Provides set via this method will be inherited into subclasses.
</p>
<p>
The <tt>format</tt> is extracted from the PATH_INFO, it simply represents
the last extension name in the path.
</p>
<p>
The <a href="Node.html#M000341">provide</a> also has influence on the
chosen templates for the {<a href="Action.html">Action</a>}.
</p>
<p>
@example providing RSS with ERB templating
</p>
<pre>
  provide :rss, :engine =&gt; :ERB
</pre>
<p>
Given a request to `/list.rss` the template lookup first tries to find
`list.rss.erb`, if that fails it falls back to `list.erb`. If neither of
these are available it will try to use the return value of the method in
the {<a href="Action.html">Action</a>} as template.
</p>
<p>
A request to `/list.yaml` would match the format &#8216;yaml&#8216;
</p>
<p>
@example providing a yaml version of actions
</p>
<pre>
  class Articles
    include Innate::Node
    map '/article'

    provide(:yaml, :type =&gt; 'text/yaml'){|action, value| value.to_yaml }

    def list
      @articles = Article.list
    end
  end
</pre>
<p>
@example providing plain text inspect version
</p>
<pre>
  class Articles
    include Innate::Node
    map '/article'

    provide(:txt, :type =&gt; 'text/plain'){|action, value| value.inspect }

    def list
      @articles = Article.list
    end
  end
</pre>
<p>
@param [Proc] block
</p>
<pre>
  upon calling the action, [action, value] will be passed to it and its
  return value becomes the response body.
</pre>
<p>
@option param :engine [Symbol String]
</p>
<pre>
  Name of an engine for View::get
</pre>
<p>
@option param :type [String]
</p>
<pre>
  default Content-Type if none was set in Response
</pre>
<p>
@raise [ArgumentError] if neither a block nor an engine was given
</p>
<p>
@api external @see View::get <a href="Node.html#M000342">Node#provides</a>
@author manveru
</p>
<p>
@todo
</p>
<pre>
  The comment of this method may be too short for the effects it has on
  the rest of Innate, if you feel something is missing please let me
  know.
</pre>
        </div>
      </div>

      <div id="method-M000375" class="method-detail">
        <a name="M000375"></a>

        <div class="method-heading">
          <a href="Node.src/M000375.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000375.html');return false;">
          <span class="method-name">provide_set?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
This will return true if the only <a href="Node.html#M000342">provides</a>
set are by {Node::included}.
</p>
<p>
The reasoning behind this is to determine whether the user has touched the
<a href="Node.html#M000342">provides</a> at all, in which case we will not
override the <a href="Node.html#M000342">provides</a> in subclasses.
</p>
<p>
@return [true, false] (false)
</p>
<p>
@api internal @see {Node::included} @author manveru
</p>
        </div>
      </div>

      <div id="method-M000342" class="method-detail">
        <a name="M000342"></a>

        <div class="method-heading">
          <a href="Node.src/M000342.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000342.html');return false;">
          <span class="method-name">provides</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000347" class="method-detail">
        <a name="M000347"></a>

        <div class="method-heading">
          <a href="Node.src/M000347.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000347.html');return false;">
          <span class="method-name">resolve</span><span class="method-args">(path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Let&#8216;s get down to business, first check if we got any wishes
regarding the representation from the client, otherwise we will assume he
wants html.
</p>
<p>
@param [String] path
</p>
<p>
@return [nil, <a href="Action.html">Action</a>]
</p>
<p>
@api external @see Node::find_provide Node::update_method_arities
Node::find_action @author manveru
</p>
        </div>
      </div>

      <div id="method-M000368" class="method-detail">
        <a name="M000368"></a>

        <div class="method-heading">
          <a href="Node.src/M000368.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000368.html');return false;">
          <span class="method-name">root_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
make sure this is an Array and a new instance so modification on the
wrapping array doesn&#8216;t affect the original option. [*arr].object_id
== arr.object_id if arr is an Array
</p>
<p>
@return [Array] list of root directories
</p>
<p>
@api external @author manveru
</p>
        </div>
      </div>

      <div id="method-M000357" class="method-detail">
        <a name="M000357"></a>

        <div class="method-heading">
          <a href="Node.src/M000357.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000357.html');return false;">
          <span class="method-name">to_layout</span><span class="method-args">(action_name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Find the best matching action_name for the <a
href="Node.html#M000358">layout</a>, if any.
</p>
<p>
This is mostly an abstract method that you might find handy if you want to
do vastly different <a href="Node.html#M000358">layout</a> lookup.
</p>
<p>
@param [String] action_name @param [String] wish
</p>
<p>
@return [nil, String] the absolute path to the template or nil
</p>
<p>
@api external @see {<a href="Node.html#M000360">Node#to_template</a>} {<a
href="Node.html#M000368">Node#root_mappings</a>} {<a
href="Node.html#M000372">Node#layout_mappings</a>} @author manveru
</p>
        </div>
      </div>

      <div id="method-M000360" class="method-detail">
        <a name="M000360"></a>

        <div class="method-heading">
          <a href="Node.src/M000360.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000360.html');return false;">
          <span class="method-name">to_template</span><span class="method-args">(path, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Try to find a template at the given <tt>path</tt> for <tt>wish</tt>.
</p>
<p>
Since <a href="../Innate.html">Innate</a> supports multiple paths to
templates the <tt>path</tt> has to be an Array that may be nested one
level.
</p>
<p>
@example Usage to find available templates
</p>
<pre>
  # This assumes following files:
  # view/foo.erb
  # view/bar.erb
  # view/bar.rss.erb
  # view/bar.yaml.erb

  class FooBar
    Innate.node('/')
  end

  FooBar.to_template(['.', 'view', '/', 'foo'], 'html')
  # =&gt; &quot;./view/foo.erb&quot;
  FooBar.to_template(['.', 'view', '/', 'foo'], 'yaml')
  # =&gt; &quot;./view/foo.erb&quot;
  FooBar.to_template(['.', 'view', '/', 'foo'], 'rss')
  # =&gt; &quot;./view/foo.erb&quot;

  FooBar.to_template(['.', 'view', '/', 'bar'], 'html')
  # =&gt; &quot;./view/bar.erb&quot;
  FooBar.to_template(['.', 'view', '/', 'bar'], 'yaml')
  # =&gt; &quot;./view/bar.yaml.erb&quot;
  FooBar.to_template(['.', 'view', '/', 'bar'], 'rss')
  # =&gt; &quot;./view/bar.rss.erb&quot;
</pre>
<p>
@param [Array&lt;Array&lt;String&gt;&gt;, Array&lt;String&gt;] path
</p>
<pre>
  array containing strings and nested (1 level) arrays containing strings
</pre>
<p>
@param [String] wish
</p>
<p>
@return [nil, String] relative path to the first template found
</p>
<p>
@api external @see <a href="Node.html#M000353">Node#find_view</a> <a
href="Node.html#M000357">Node#to_layout</a> <a
href="Node.html#M000356">Node#find_aliased_view</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000354" class="method-detail">
        <a name="M000354"></a>

        <div class="method-heading">
          <a href="Node.src/M000354.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000354.html');return false;">
          <span class="method-name">to_view</span><span class="method-args">(action_name, wish)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Try to find the best template for the given basename and wish.
</p>
<p>
This method is mostly here for symetry with {<a
href="Node.html#M000357">to_layout</a>} and to allow you overriding the
template lookup easily.
</p>
<p>
@param [to_s] action_name @param [to_s] wish
</p>
<p>
@return [String, nil] depending whether a template could be found
</p>
<p>
@api external @see {<a href="Node.html#M000353">Node#find_view</a>} {<a
href="Node.html#M000360">Node#to_template</a>} {<a
href="Node.html#M000368">Node#root_mappings</a>}
</p>
<pre>
     {Node#view_mappings} {Node#to_template}
</pre>
<p>
@author manveru
</p>
        </div>
      </div>

      <div id="method-M000344" class="method-detail">
        <a name="M000344"></a>

        <div class="method-heading">
          <a href="Node.src/M000344.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000344.html');return false;">
          <span class="method-name">try_resolve</span><span class="method-args">(path)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Let&#8216;s try to find some valid action for given <tt>path</tt>.
Otherwise we dispatch to {<a href="Node.html#M000346">action_missing</a>}.
</p>
<p>
@param [String] path from env[&#8216;PATH_INFO&#8217;]
</p>
<p>
@return [<a href="Response.html">Response</a>]
</p>
<p>
@api external @see <a href="Node.html#M000347">Node#resolve</a> <a
href="Node.html#M000345">Node#action_found</a> <a
href="Node.html#M000346">Node#action_missing</a> @author manveru
</p>
        </div>
      </div>

      <div id="method-M000363" class="method-detail">
        <a name="M000363"></a>

        <div class="method-heading">
          <a href="Node.src/M000363.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000363.html');return false;">
          <span class="method-name">update_layout_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000364" class="method-detail">
        <a name="M000364"></a>

        <div class="method-heading">
          <a href="Node.src/M000364.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000364.html');return false;">
          <span class="method-name">update_mapping_shared</span><span class="method-args">(paths)</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000352" class="method-detail">
        <a name="M000352"></a>

        <div class="method-heading">
          <a href="Node.src/M000352.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000352.html');return false;">
          <span class="method-name">update_method_arities</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Answer with a hash, keys are method names, values are method arities.
</p>
<p>
Note that this will be executed once for every request, once we have
settled things down a bit more we can switch to update based on Reloader
hooks and update once on startup. However, that may cause problems with
dynamically created methods, so let&#8216;s play it safe for now.
</p>
<p>
@example
</p>
<pre>
  Hi.update_method_arities
  # =&gt; {'index' =&gt; 0, 'foo' =&gt; -1, 'bar =&gt; 2}
</pre>
<p>
@api internal @see <a href="Node.html#M000347">Node#resolve</a> @return
[Hash] <a href="Node.html#M000339">mapping</a> the name of the methods to
their arity
</p>
        </div>
      </div>

      <div id="method-M000361" class="method-detail">
        <a name="M000361"></a>

        <div class="method-heading">
          <a href="Node.src/M000361.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000361.html');return false;">
          <span class="method-name">update_template_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000362" class="method-detail">
        <a name="M000362"></a>

        <div class="method-heading">
          <a href="Node.src/M000362.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000362.html');return false;">
          <span class="method-name">update_view_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000370" class="method-detail">
        <a name="M000370"></a>

        <div class="method-heading">
          <a href="Node.src/M000370.html" target="Code" class="method-signature"
            onclick="popupCode('Node.src/M000370.html');return false;">
          <span class="method-name">view_mappings</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Combine Innate.options.views with either the `ancestral_trait[:views]` or
the {<a href="Node.html#M000339">Node#mapping</a>} if the trait yields an
empty Array.
</p>
<p>
@return [Array&lt;String&gt;, Array&lt;Array&lt;String&gt;&gt;]
</p>
<p>
@api external @see {<a href="Node.html#M000369">Node#map_views</a>} @author
manveru
</p>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>